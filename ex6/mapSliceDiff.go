package main

import "fmt"

// ポインタ型の値を渡して変更を加える
// 特にMap。この設計はAPI等では避けるべき -> mapのstringはkeyを矯正できないので、コードを読まないと仕様が不明
func badPattern(base map[string]int) {
	base["coin"] += 100
}

// スライスを関数で渡した場合、関数内でスライスの内容は変わる
// スライスの値は関数の中で変化するが、渡した元の方よりサイズが大きくなると、元のスライスは大きさは変わらない
// そのため大元の方からは値の変化が追えない
// 要素の変更は反映されるけど、サイズ（＝内部配列の再確保を伴う操作）は元に影響しないことがあります。
func sliceFunc(coins []int) {
	coins[0] = 100
	coins = append(coins, 999)
}

// ガベージコレクションが存在するとはいえ、不要なメモリを確保するのオーバヘッドを産む
// bad: 1回しか使われないデータチャンクを、ループのたびに割り当てる -> 不必要なメモリ割り当てが大量発生
// good: スライスを1度だけ作成しデータソースからデータを読み込む -> 使いまわす

func main() {
	var coin = map[string]int{"coin": 0}
	var coins = []int{1, 2, 3}
	badPattern(coin)
	fmt.Println(coin)
	sliceFunc(coins)
	fmt.Println(coins)
}

// ガベージ -> どのポインタにも参照されてないデータ
// どのポインタも参照してないので、無駄なメモリ割り当て->回収してシステムが再利用
// このお仕事をするのがガベージコレクタ
// スタック -> 一連のメモリブロック
// 実行されるスレッドの全ての関数呼び出しが同じメモリブロックを共有
// 最後にデータが保存されたメモリの位置がスラックポインタ。追加でメモリを割り当てる際には、スタックポインタが動く
// スタックフレームが生成され、そこに新しいローカル変数が割り当てられる
// 関数終了 -> 関数のローカル変数や引数に使用されていたスタック上のメモリが解放

// 関数終了 -> データをスタック上に保存できないコンパイラ判断(エスケープ) -> ヒープ上に保存
// ヒープはガベージコレクタが管理するメモリ。値はデータを参照してるスタック上のポインタ型変数がある限り有効
// 参照しているポインタが存在しなくなった場合、データはガベージになる。回収はガベージコレクタの仕事

// データをヒープに保存するべきではない理由2戦
// 1: ガベージコレクタの作業に時間がかかる。ヒープ上のメモリ管理が大変になる。
// 2: 構造体と基本スライスはRAMにシーケンシャルに格納されてて、取り出しが早いが、ポインタは散らばっておかれるので、取り出しが遅い。
// HWを意識してコードを書くのを mechanical sympathyというらしいが、Goのベストプラクティスに従ってイディオムなコードを書くとこれを満たせる
